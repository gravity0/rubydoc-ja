<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja-JP">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Language" content="ja-JP">
  <link rel="stylesheet" type="text/css" href="../style.css">
  <link rel="icon" type="image/png" href="../rurema.png">
  <title>library irb</title>
  <link rel="search" type="application/opensearchdescription+xml" title="Ruby 1.9.2 リファレンスマニュアル" href="/opensearchdescription">
</head>
<body>

<p>
<a href="../doc/index.html">Ruby 1.9.2 リファレンスマニュアル</a>
&gt; <a href="../library/index.html">ライブラリ一覧</a>
&gt; irbライブラリ
</p>



<h1>library irb</h1>




<h2>要約</h2>
<p>
irb は Interactive Ruby の略です。
irb を使うと、Ruby の式を標準入力から簡単に入力・実行することができます。
</p>
<h2 >irb の使い方</h2>
<p>
Ruby さえ知っていれば irb を使うのは簡単です。
irb コマンドを実行すると、以下のようなプロンプトが表れます。
</p>
<pre>
$ irb
irb(main):001:0&gt;
</pre>
<p>
あとは Ruby の式を入力するだけで、その式が実行され、結果が表示されます。
</p>
<pre>
irb(main):001:0&gt; 1+2
3
irb(main):002:0&gt; class Foo
irb(main):003:1&gt;   def foo
irb(main):004:2&gt;     print 1
irb(main):005:2&gt;   end
irb(main):006:1&gt; end
nil
irb(main):007:0&gt;
</pre>
<p>
また irb コマンドは <a href="../library/readline.html">readline</a> ライブラリにも対応しています。
readline ライブラリがインストールされている時には
自動的にコマンドライン編集や履歴の機能が使えるようになります。
</p>
<h2 >irb のコマンドラインオプション</h2>
<pre>
irb [options] file_name opts
options:
-f                ~/.irbrc を読み込まない
-m                bc モード (分数と行列の計算ができる)
-d                $DEBUG を true にする (ruby -d と同じ)
-Kc               ruby -Kc と同じ
-r library        ruby -r と同じ
-I                ruby -I と同じ
--verbose         これから実行する行を表示する (デフォルト)
--noverbose       これから実行する行を表示しない
--echo            実行結果を表示する (デフォルト)
--noecho          実行結果を表示しない
--inspect         結果出力にinspectを用いる (bc モード以外ではデフォルト)
--noinspect       結果出力にinspectを用いない
--readline        readlineライブラリを利用する
--noreadline      readlineライブラリを利用しない。デフォルトでは
                  inf-ruby-mode 以外で readline ライブラリを利用する。
--prompt prompt-mode
--prompt-mode prompt-mode
                  プロンプトモードを切り替える。現在定義されているプ
                  ロンプトモードは、default/simple/xmp/inf-ruby。
--inf-ruby-mode   emacsのinf-ruby-mode 用のプロンプト表示を行なう。
                  特に指定がない限り readline ライブラリは使わなくなる。
--simple-prompt
                  非常にシンプルなプロンプトを用いるモード。
--noprompt        プロンプトを表示しない。
--tracer          コマンド実行時にトレースする。
--back-trace-limit n
                  バックトレース表示をバックトレースの頭から n、
                  うしろから n だけ行なう。デフォルト値は 16。
--irb_debug n     irb のデバッグレベルを n に設定する
                  (ユーザは利用すべきではない)
-v, --version     irb のバージョンを表示する
</pre>
<h2 >irb のカスタマイズ</h2>
<p>
irb コマンドは起動時にホームディレクトリの .irbrc というファイルを読み込みます。
.irbrc は Ruby スクリプトです。ホームディレクトリに .irbrc が存在しない場合は、
カレントディレクトリの .irbrc, irb.rc, _irbrc, $irbrc を順番にロードしようと
試みます。
</p>
<p>
以下のような (Ruby の) 式を .irbrc に記述すると、
irb コマンドのオプションを指定したのと同じ効果が得られます。
</p>
<pre>
IRB.conf[:AUTO_INDENT] = false
IRB.conf[:BACK_TRACE_LIMIT] = 16
IRB.conf[:DEBUG_LEVEL] = 1
IRB.conf[:ECHO] = nil
IRB.conf[:EVAL_HISTORY] = nil
IRB.conf[:HISTORY_FILE] = nil
IRB.conf[:IGNORE_EOF] = true
IRB.conf[:IGNORE_SIGINT] = true
IRB.conf[:INSPECT_MODE] = nil
IRB.conf[:IRB_NAME] = &quot;irb&quot;
IRB.conf[:IRB_RC] = nil
IRB.conf[:MATH_MODE] = false
IRB.conf[:PROMPT] = {....}
IRB.conf[:PROMPT_MODE] = :DEFAULT
IRB.conf[:SINGLE_IRB] = false
IRB.conf[:SAVE_HISTORY] = nil
IRB.conf[:USE_LOADER] = true
IRB.conf[:USE_READLINE] = nil
IRB.conf[:USE_TRACER] = true
IRB.conf[:VERBOSE] = true
</pre>
<h3 >プロンプトのカスタマイズ</h3>
<p>
irb のプロンプトをカスタマイズしたい時は、
まず独自のプロンプトモードを作成し、
それをコマンドラインや .irbrc に指定します。
</p>
<p>
まず、新しいプロンプトモードを作成するには、
例えば .irbrc で以下のように記述します。
</p>
<pre>
# 新しいプロンプトモード MY_PROMPT を作成する
IRB.conf[:PROMPT][:MY_PROMPT] = {
  :PROMPT_I =&gt; nil,          # 通常時のプロンプト
  :PROMPT_S =&gt; nil,          # 文字列などの継続行のプロンプト
  :PROMPT_C =&gt; nil,          # 式が継続している時のプロンプト
  :RETURN =&gt; &quot;    ==&gt;%s\n&quot;   # メソッドから戻る時のプロンプト
}
</pre>
<p>
いま作成した新しいプロンプトモードを使うには、
以下のように irb コマンドに --prompt オプションを指定します。
</p>
<pre>
$ irb --prompt my-prompt
</pre>
<p>
毎回指定するのが面倒なら、.irbrc に以下の式を記述します。
</p>
<pre>
# プロンプトモード MY_PROMPT を使う
IRB.conf[:PROMPT_MODE] = :MY_PROMPT
</pre>
<p>
PROMPT_I, PROMPT_S, PROMPT_C にはフォーマット文字列を指定します。
フォーマット文字列では <a href="../method/-kernel/m/printf.html">Kernel.#printf</a> のように
「%」を用いた記法が使えます。
フォーマット文字列で使用可能な記法は以下の通りです。
</p>
<dl>
<dt>%N</dt>
<dd>
<p>
起動しているコマンド名
</p>
</dd>
<dt>%m</dt>
<dd>
<p>
main オブジェクト (self) を to_s した文字列
</p>
</dd>
<dt>%M</dt>
<dd>
<p>
main オブジェクト (self) を inspect した文字列
</p>
</dd>
<dt>%l</dt>
<dd>
<p>
文字列中のタイプを表す (&quot;, ', /, ], `]'は%wの中の時)
</p>
</dd>
<dt>%NNi</dt>
<dd>
<p>
インデントのレベルを、NN 桁に右詰めした文字列。
NN は省略可能。
</p>
</dd>
<dt>%NNn</dt>
<dd>
<p>
行番号を、NN 桁に右詰めした文字列。
NN は省略可能。
</p>
</dd>
<dt>%%</dt>
<dd>
<p>
文字「%」それ自体
</p>
</dd>
</dl>
<p>
また、RETURN は現在のところ printf と全く同じ形式で指定します。
ただし、将来は仕様が変わる可能性があります。
</p>
<p>
例えば、デフォルトのプロンプトモードである
「default」プロンプトモードは以下のように設定されています。
</p>
<pre>
IRB.conf[:PROMPT_MODE][:DEFAULT] = {
  :PROMPT_I =&gt; &quot;%N(%m):%03n:%i&gt; &quot;,
  :PROMPT_S =&gt; &quot;%N(%m):%03n:%i%l &quot;,
  :PROMPT_C =&gt; &quot;%N(%m):%03n:%i* &quot;,
  :RETURN =&gt; &quot;%s\n&quot;
}
</pre>
<p>
プロンプトモードは :DEFAULT
の他に :NULL, :CLASSIC, :SIMPLE, :XMP が定義されています。
</p>
<h2 >サブ irb</h2>
<p>
irb では、起動時の irb インタプリタとは独立した環境を持つ
「サブ irb」を任意の数だけ起動することができます。
サブ irb は、irb 実行中に「irb」と入力すると起動します。
</p>
<p>
例えば以下の実行例を見てください。
</p>
<pre>
irb(main):004:0&gt; x = &quot;OK&quot;          # ローカル変数 x を定義
=&gt; &quot;OK&quot;
irb(main):005:0&gt; x                 # x を表示
=&gt; &quot;OK&quot;
irb(main):006:0&gt; irb               # サブ irb を起動
irb#1(main):001:0&gt; x               # x を表示
NameError: undefined local variable or method `x' for main:Object
        from (irb#1):1:in `Kernel#binding'
</pre>
<p>
起動時のインタプリタでローカル変数 x を定義しましたが、
「irb」でサブ irb を起動すると、
ローカル変数 x が見えなくなっています。
これが「独立した環境」の意味です。
</p>
<h2 >サブ irb の設定</h2>
<p>
irb コマンド起動時のインタプリタの設定は
コマンドラインオプションと IRB.conf の値で決まります。
それに対して、サブ irb インタプリタの設定は、
各インタプリタの「conf」オブジェクトの値で決まります。
</p>
<p>
conf オブジェクトの値を変更するには、
まず以下のようにサブ irb を起動してから conf オブジェクトの
値を一つ一つ変更する方法があります。
</p>
<pre>
$ irb
irb(main):001:0&gt; irb                     # サブ irb を起動
irb#1(main):001:0&gt; conf.prompt_i         # prompt_i の値を確認
=&gt; &quot;%N(%m):%03n:%i&gt; &quot;
irb#1(main):002:0&gt; conf.prompt_i = &quot;&gt;&quot;   # prompt_i の値を変更
=&gt; &quot;&gt;&quot;
&gt;                                        # プロンプトが変わった
</pre>
<p>
しかし、サブ irb を起動するたびに設定を入力するのは面倒です。
そこで、IRB.conf[:IRB_RC] を使う方法を紹介します。
</p>
<p>
IRB.conf[:IRB_RC] に Proc オブジェクトを設定しておくと、
サブ irb が起動されるたびに、その Proc オブジェクトに
IRB::Context オブジェクトを渡して実行します。
これによってサブ irb の設定をまとめて設定することができます。
</p>
<p>
以下に例を示します。
</p>
<pre>
$ irb
irb(main):001:0&gt; IRB.conf[:IRB_RC] = lambda {|conf| conf.prompt_i = &quot;&gt; &quot; }
=&gt; #&lt;Proc:0x00002a95fa3fd8@(irb):2&gt;
irb(main):002:0&gt; irb
&gt;
</pre>
<h2 >irb の使用例</h2>
<p>
irb のいろいろな使用例を以下に示します。
</p>
<pre>
$ irb
irb(main):001:0&gt; irb                        # サブirbの立ちあげ
irb#1(main):001:0&gt; jobs                     # サブirbのリスト
#0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : stop)
#1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : running)
nil
irb#1(main):002:0&gt; fg 0                     # jobのスイッチ
nil
irb(main):002:0&gt; class Foo;end
nil
irb(main):003:0&gt; irb Foo                    # Fooをコンテキストしてirb
                                            # 立ちあげ
irb#2(Foo):001:0&gt; def foo                   # Foo#fooの定義
irb#2(Foo):002:1&gt;   print 1
irb#2(Foo):003:1&gt; end
nil
irb#2(Foo):004:0&gt; fg 0                      # jobをスイッチ
nil
irb(main):004:0&gt; jobs                       # jobのリスト
#0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : running)
#1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : stop)
#2-&gt;irb#2 on Foo (#&lt;Thread:0x4011d54c&gt; : stop)
nil
irb(main):005:0&gt; Foo.instance_methods       # Foo#fooがちゃんと定義さ
                                            # れている
[&quot;foo&quot;]
irb(main):006:0&gt; fg 2                       # jobをスイッチ
nil
irb#2(Foo):005:0&gt; def bar                   # Foo#barを定義
irb#2(Foo):006:1&gt;  print &quot;bar&quot;
irb#2(Foo):007:1&gt; end
nil
irb#2(Foo):010:0&gt;  Foo.instance_methods
[&quot;bar&quot;, &quot;foo&quot;]
irb#2(Foo):011:0&gt; fg 0
nil
irb(main):007:0&gt; f = Foo.new
#&lt;Foo:0x4010af3c&gt;
irb(main):008:0&gt; irb f                      # Fooのインスタンスでirbを
                                            # 立ちあげる.
irb#3(#&lt;Foo:0x4010af3c&gt;):001:0&gt; jobs
#0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : stop)
#1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : stop)
#2-&gt;irb#2 on Foo (#&lt;Thread:0x4011d54c&gt; : stop)
#3-&gt;irb#3 on #&lt;Foo:0x4010af3c&gt; (#&lt;Thread:0x4010a1e0&gt; : running)
nil
irb#3(#&lt;Foo:0x4010af3c&gt;):002:0&gt; foo         # f.fooの実行
nil
irb#3(#&lt;Foo:0x4010af3c&gt;):003:0&gt; bar         # f.barの実行
barnil
irb#3(#&lt;Foo:0x4010af3c&gt;):004:0&gt; kill 1, 2, 3# jobのkill
nil
irb(main):009:0&gt; jobs
#0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : running)
nil
irb(main):010:0&gt; exit                       # 終了
$
</pre>
<h2 >使用上の制限</h2>
<p>
irbは, 評価できる時点(式が閉じた時点)での逐次実行を行ないます.
したがって, rubyを直接使った時と若干異なる動作を行なう場合があります.
</p>
<p>
現在明らかになっている問題点を説明します.
</p>
<h3 >ローカル変数の宣言</h3>
<p>
Ruby では以下のプログラムはエラーになります.
</p>
<pre>
eval &quot;foo = 0&quot;
p foo    # -:2: undefined local variable or method `foo' for #&lt;Object:0x40283118&gt; (NameError)
</pre>
<p>
ところが irb を用いると、以下のように、エラーになりません。
</p>
<pre>
&gt;&gt; eval &quot;foo = 0&quot;
=&gt; 0
&gt;&gt; foo
=&gt; 0
</pre>
<p>
この違いは、Ruby と irb のプログラムのコンパイル方法の差に起因します。
Ruby は最初にスクリプト全体をコンパイルしてローカル変数を決定します。
それに対し、irb は式が完結して実行可能になった時点で順番にコンパイルします。
上記の例では、
</p>
<pre>
eval &quot;foo = 0&quot;
</pre>
<p>
が入力された時点でまずその式をコンパイル・実行します。
この時点で変数 foo が定義されるため、
次の式を入力する時点ですでに変数 foo が定義されているのです。
</p>
<p>
この Ruby と irb の動作の違いをなくしたい場合は、
irb では以下のように式を begin 〜 end でくくって入力してください。
</p>
<pre>
&gt;&gt; begin
?&gt;   eval &quot;foo = 0&quot;
&gt;&gt;   foo
&gt;&gt; end
NameError: undefined local variable or method `foo' for #&lt;Object:0x4013d0f0&gt;
(irb):3
(irb_local_binding):1:in `eval'
</pre>
<h3 >ヒアドキュメント</h3>
<p>
現在のところヒアドキュメントの実装は不完全です。
</p>
<h3 >シンボル</h3>
<p>
irb はシンボルであるかどうかの判断を間違えることがあります。
具体的には、式が完了しているのに継続行と見なすことがあります。
</p>


<h2>クラスとモジュール</h2>
<table class="entries libraries">

<tr>
<td class="signature"><a href="../class/-i-r-b=3a=3a-context.html">class IRB::Context</a></td>
<td class="description"></td>
</tr>

<tr>
<td class="signature"><a href="../class/-irb-commands.html">class IrbCommands</a></td>
<td class="description"><p>
このクラスは irb のコマンドをまとめるためのプレースホルダです。
実際には IrbCommands というクラスは定義されていません。
このクラスのドキュメントに記述されているメソッドは、
irb のプロンプトでレシーバなしで使うことができます。
</p>
</td>
</tr>

</table>


<h2>サブライブラリ</h2>
<table class="entries libraries">

<tr>
<td class="signature"><a href="../library/irb=2fcompletion.html">irb/completion</a></td>
<td class="description"><p>
irb の completion 機能を提供するものです.
</p>
</td>
</tr>

<tr>
<td class="signature"><a href="../library/irb=2fframe.html">irb/frame</a></td>
<td class="description"></td>
</tr>

<tr>
<td class="signature"><a href="../library/irb=2fxmp.html">irb/xmp</a></td>
<td class="description"><p>
コードとその実行結果を、行ごとに交互に表示するためのライブラリです。
irb を実行しなくても、使うことが出来ます。
ごとけん xmp (<a class="external" href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-list/8489">[ruby-list:8489]</a>)の上位互換バージョンです.
ただ, 非常に重いのでごとけん xmp では対応できない時に使用すると良いでしょう.
</p>
</td>
</tr>

</table>




<div id="footer">
  <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">
    <img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/88x31.png" />
  </a>
</div>
</body>
</html>
